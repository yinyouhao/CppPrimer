# 第1章 开始

1. IDE：集成开发环境

# 第I部分 C++基础

## 第2章 变量和基本类型

## 第3章 字符串、向量和数组

## 第4章 表达式

1. 当一个对象被用作右值，用的是对象的值（内容）；当对象用作左值的时候，用的是对象的身份（在内存中的位置）

2. 使用关键字decltype，左值和右值有所不同。表达式求值结果为左值，得到一个引用类型。p121

3. 对于那些没有指定执行顺序的运算符来说，表达式指向并修改同一个值会引发错误并产生未定义行为。

   - <<没有规定执行顺序

     ```c++
     int i=0;
     cout<<i<<i++;
     //错误
     
     while(beg!=s.end() && !isspace(*beg))
         *beg=toupper(*beg++);
     //错误
     ```
     
   - 有四种规定了运算顺序的：&&     ||      ?:        ,
   
4. 如果改变了某个运算对象的值，在同一表达式的其他地方就不要在使用这个运算对象；

   当表达式的子表达式本身就是另一个子表达式的运算对象时除外。例如*++iter 。

5. m%n不等于0，则它的符号和==m相同==

6. 短路求值：逻辑与和逻辑或都是短路求值。与：前面符合才求后面，或：前面不符合才求后面。

7. 赋值运算符=满足右结合律（且赋值运算符的级别很低）即：

   ```c++
   int iva1,iva2;
   iva1=iva2=0; //正确
   ```

8. ++i和i++：除非必须，不建议使用后置

9. 仅建议将位运算符应用于无符号类型

![image-20201214160229759](../Typora笔记/assets/image-20201214160229759.png)

10. sizeof运算符

    返回一条表达式或者一个类型名字所占的字节数，返回类型为==size_t==型

    - 调用方式：sizeof (type) 或者 sizeof expr
    - char：1
    - 引用类型：被引用对象占空间大小
    - 指针：指针本身所占大小
    - 解引用指针：指针指向的对象所占空间大小，指针无需有效
    - 数组：整个数组所占大小，不被当作指针
    - string和vector：==返回固定大小==

![image-20201214162114789](../Typora笔记/assets/image-20201214162114789.png)

11. 命名的强制类型转换：cast-name\<转换的目标类型>(要转换的值);  （尽量别用）

    - static-cast：任何具有明确定义的类型转换，只要不包含底层的const，就可以使用static-cast。

      其强制强制转换的结果将与原始数据地址值相等，因此要确保转换后的类型为指针所指的类型。

    - const-cast：只能改变运算对象的底层const，不能用来改变表达式；只改变常量属性，不改变类型

```c++
const char *cp;
static_cast<string>(cp);//正确，字符串字面值转为string类型
const_cast<string>(cp);//错误，只改变常量属性
```

11. 旧式强制类型转换：
    - type (expr)：函数类型的强制类型转换
    - (type) expr：C语言风格的强制类型转换